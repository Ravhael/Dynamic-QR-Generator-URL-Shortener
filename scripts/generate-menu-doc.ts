#!/usr/bin/env ts-node
/**
 * Script: generate-menu-doc.ts
 * Purpose: Generate docs/MENU_STRUCTURE.md from current database menu_items + menu_role_permissions
 * Usage:  npx ts-node scripts/generate-menu-doc.ts
 */
// Using relative import to avoid needing tsconfig path resolution when running via ts-node
import { prisma } from '../lib/prisma';
import * as fs from 'fs';
import * as path from 'path';

interface TreeNode {
  id: string;
  name: string;
  path?: string | null;
  icon?: string | null;
  children?: TreeNode[];
  permissions?: Record<string, { view: boolean; create: boolean; edit: boolean; delete: boolean; export: boolean; accessible: boolean }>
}

async function buildTree() {
  const items = await prisma.menu_items.findMany({ orderBy: { sort_order: 'asc' } });
  const perms = await prisma.menu_role_permissions.findMany();
  const permMap = perms.reduce((acc, p) => {
    const key = p.menu_item_id;
    if (!acc[key]) acc[key] = [];
    acc[key].push(p);
    return acc;
  }, {} as Record<number, typeof perms>);

  const byMenuId = new Map(items.map(i => [i.menu_id, i]));
  const childrenMap: Record<string, typeof items> = {};
  for (const it of items) {
    const parent = it.parent_id || '__root__';
    childrenMap[parent] = childrenMap[parent] || [];
    childrenMap[parent].push(it as any);
  }

  function nodeFor(menuId: string): TreeNode | null {
    const item = items.find(i => i.menu_id === menuId);
    if (!item) return null;
    const pRows = permMap[item.id] || [];
    const rolePerms: TreeNode['permissions'] = {};
    for (const r of pRows) {
      rolePerms[r.role_name] = {
        view: r.can_view,
        create: r.can_create,
        edit: r.can_edit,
        delete: r.can_delete,
        export: r.can_export,
        accessible: (r as any).is_accessible ?? r.can_view
      };
    }
    const kids = childrenMap[item.menu_id] || [];
    return {
      id: item.menu_id,
      name: item.name,
      path: item.path,
      icon: item.icon,
      permissions: rolePerms,
      ...(kids.length ? { children: kids.map(k => nodeFor(k.menu_id)!).filter(Boolean) } : {})
    };
  }

  const roots = (childrenMap['__root__'] || []).map(r => nodeFor(r.menu_id)!).filter(Boolean);
  return roots;
}

function renderMarkdown(tree: TreeNode[]): string {
  const lines: string[] = [];
  lines.push('# Menu Structure (Auto-Generated)');
  lines.push('');
  lines.push('> DO NOT EDIT MANUALLY. Generated by scripts/generate-menu-doc.ts');
  lines.push('');
  function walk(nodes: TreeNode[], depth = 0) {
    for (const n of nodes) {
      const indent = '  '.repeat(depth);
      const perms = n.permissions && Object.keys(n.permissions).length
        ? ' [' + Object.entries(n.permissions).map(([role, p]) => `${role}:` + (p.accessible ? '✓' : '✗')).join(', ') + ']'
        : '';
      lines.push(`${indent}- **${n.name}** (
${indent}  id: ${n.id}${n.path ? `, path: ${n.path}` : ''}${perms ? ',' : ''}`);
      if (perms) {
        lines.push(`${indent}  permissions:`);
        for (const [role, p] of Object.entries(n.permissions!)) {
          lines.push(`${indent}    - ${role}: view=${p.view} create=${p.create} edit=${p.edit} delete=${p.delete} export=${p.export} accessible=${p.accessible}`);
        }
      }
      lines.push(`${indent})`);
      if (n.children?.length) walk(n.children, depth + 1);
    }
  }
  walk(tree);
  return lines.join('\n');
}

async function main() {
  const tree = await buildTree();
  const md = renderMarkdown(tree);
  const outPath = path.join(process.cwd(), 'docs', 'MENU_STRUCTURE.md');
  fs.writeFileSync(outPath, md, 'utf8');
  console.log(`Generated ${outPath}`);
  await prisma.$disconnect();
}

main().catch(err => {
  console.error('Generation failed', err);
  prisma.$disconnect();
  process.exit(1);
});
